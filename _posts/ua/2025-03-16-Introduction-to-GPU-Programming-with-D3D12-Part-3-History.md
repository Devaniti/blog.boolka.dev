---
layout: post
title:  "Вступ до GPU програмування з D3D12: Частина 3 - Історія"
date:   2025-03-16 4:01:00 +0900
categories: Introduction_to_GPU_Programming_with_D3D12
lang: ua
---

[Попередній пост](Introduction-to-GPU-Programming-with-D3D12-Part-2-Why-do-we-need-GPUs.html)

Сучасне GPU програмування має своє коріння у обрахунку 3D графіки в реальному часі. Розуміння цієї історії допоможе вам простіше розібратись чому GPU програмування так сьогодні виглядає.

Зауважте, що ігри з цього списку можуть бути не першим прикладом відповідних методів. Як виявляється, це доволі складно яка саме гра була першою у запровадженні того чи іншого методу.

## Перетворення геометрії

Battlezone (1980) використав рендеринг каркасу (wireframe rendering).

<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/Ctr54kopo8I?si=EscADUKrUjz3W9kv" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

Об'єкти представлено у вигляді точок і ліній між ними. Щоб відрендерити їх, враховується позиція, поворот і масштаб кожного об'єкта разом з позицією, поворотом і полем зору камери, для того щоб зпроектувати ці точки на екран. Після чого, малюються лінії між цими точками, щоб зробити іллюзію 3D об'єкта.

## Трикутники

I, Robot (1984) використав рендеринг суцільних трикутників (solid triangle rendering).

<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/gmvWxG2zvs8?si=C6YQvcufy_aO7bck" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

Використовуючи трикутник замість лінії, можна задати площу екрану, яку можна заповнити. Однак це саме по собі ще не вирішує проблему оклюзії. Щоб отримати правильну оклюзію, вам також потрібно переконатися, що об’єкт, який знаходиться ближче до камери, малюється поверх об’єктів, які знаходяться далі від камери.

Ми можемо досягти цього, відсортувавши об’єкти на основі відстані до камери, щоб у результуючому списку ми спочатку мали об’єкти позаду, а в кінці – об’єкти спереду, тобто сортування ззаду наперед (back to front). Таким чином, будь-який піксель, заповнений об’єктами ззаду, може бути перезаписаний об’єктами спереду, ефективно реалізуючи оклюзію. Цей підхіт також відомий як [Алгоритм художника](https://uk.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D1%85%D1%83%D0%B4%D0%BE%D0%B6%D0%BD%D0%B8%D0%BA%D0%B0).

Однак є ще одна проблема: вам також потрібно забезпечити правильну оклюзію між різними трикутниками об’єкта. Це означає що вам також потрібно сортувати трикутники у рамках об’єкта ззаду наперед. Але є ще один трюк, який ми можемо використати щоб зменшити кількість трикутників які нам потрібно сортувати та малювати. Для кожного трикутника ми можемо визначити напрямок до якого він буде спрямований. За допомогою цієї інформації ми можемо перевірити чи він спрямований трикутник до камери чи від неї. Ми знаємо що всі трикутники, які ми побачимо, мають бути спрямовані до камери, тому ми можемо просто пропустити всі трикутники спрямовані від камери. Цей метод відомий як back-face culling.

## Текстурування

Ultima Underworld: The Stygian Abyss (1992) використав тектурування.

<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/ee4PUcpGSn8?si=ZAKEYQxgPbdf7k2A" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

Текстурування дозволяє не просто заливати трикутники суцільним кольором. Це робиться шляхом проекції текстури, яку можна уявити як двовимірну сітку кольорів, на трикутник. Кожна вершина відображається в точці на цій текстурі, і коли ви малюєте трикутник, ви можете інтерполювати положення на текстурі на основі відстані до вершин трикутника, зчитувати значення з цієї точки на текстурі, а потім використовувати цей колір для пікселя.

## Буфер глибини

Quake (1996) використовує буфер глибини (depth buffer).

<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/ZHT2TgMX7Rg?si=yVbRU-nClFMBJSQP" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

Досі вам доводилося сортувати всі об'єкти та трикутники ззаду наперед, щоб отримати правильний порядок. Але є інший спосіб. Що, якщо замість сортування трикутників ми будемо просто стежити за тим, на якій відстані кожен піксель від камери? Для цього ми створимо текстуру розміром з екран, у якій кожен піксель зберігатиме число з плаваючою комою, що відповідає відстані від камери. Таким чином ми можемо пропустити сортування об’єктів і трикутників, а також отримати додаткову інформацію про кінцеве зображення, яке ми можемо пізніше використовувати для деяких додаткових ефектів.

Ось приклад того, як може виглядати буфер глибини. Натисніть щоб переглянути повне зображення.

[![Буфер Глибини]({{ site.baseurl }}/images/DepthBuffer.webp)]({{ site.baseurl }}/images/DepthBuffer.png)

Також, оскільки вам більше не потрібно мати визначений порядок об’єктів і трикутників по відстані до камери, цей метод вам також дозволяэ рендерити у випадках перетину об’єктів і трикутників.

## Освітлення

Quake (1996) також використав обрахунок освітлення (shaded lighting).

Давайте повторимо як ви малюєте трикутник: спочатку ви отримуєте свої вершини, виконуєте певні обчислення для кожної вершини, зокрема відображаючи точки на екрані, знаходите набір пікселів на екрані який належить до трикутника, і для кожного пікселя виконуєте обчислення необхідні для відображення текстури. Це добре, але чому б не виконати більше обчислень, щоб ми могли спробувати отримати більш реалістичні результати.

Що зробив Quake, так це розрахував освітлення для кожної з вершин. Оскільки ви знаєте положення вершини в сцені, ви можете пройти циклом по джерелах світла та для кожного обчислити, скільки світла потрапляэ на поверхню поруч з вершиною. Підсумуйте результати всіх джерел світла, і ви отримаєте освітлення для заданої вершини. Потім, малюючи кожен піксель, окрім інтерполяції координат текстури ще інтерполюйте результат освітлення, і ви отримаєте базовий розрахунок освітлення.

Unreal (1998) використав обрахунок освітляння для кожного пікселя (per-pixel shaded lighting).

<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/J4fJWvckmFQ?si=wU7qFyi12XdbGJep" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

Така сама ідея, як і в Quake, але замість того, щоб обчислювати освітлення на вершину, а потім інтерполювати результати, Unreal виконує обчислення на піксель, що забезпечує точніші результати. Цікавий факт: це перша гра на рушії Unreal Engine, яка і дала назву рушію.

## Shadow Mapping (Проекція тіней)

Oddworld: Munch's Oddysee (2001) використав shadow mapping.

<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/Aa_hZKSrck0?si=Vz6Rsdq7HiOl5s86" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

Виявляється, ви можете вирішити проблему обчислення затінення використовуючи буфер глибини специфічним чином. Спочатку ви візуалізуєте сцену з точки зору джерела світла використовуючи буфер глибини. Після того як це буде зроблено, у вас буде текстура яка має всю геометрію яку можна побачити під світлом. Вся інша геометрія, яку не можна побачити з точки зору джерела світла, тоді буде у тіні. Використовуючи цю текстуру ви можете перевірити чи видно задану точку на поверхні. Буфер глибини обрахований з ціллю обрахунку затінення називають картою тіней (shadowmap).

Ось приклад того, як може виглядати карта тіней. Натисніть щоб переглянути повне зображення.

[![Карта Тіней]({{ site.baseurl }}/images/Shadowmap.webp)]({{ site.baseurl }}/images/Shadowmap.png)

## Програмуємі Шейдери (Programmable Shaders)

Технічне демо від Nvidia, Chameleon (2001) використав програмуємі шейдери

<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/Qt6Vb09qrrI?si=ctB7SIH2phpU3zcL" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

Графіка в реальному часі на практиці можлива лише тоді, коли її візуалізує GPU. Але до цього технічного демо, GPU не могли виконувати довільні обчислення. Усі розрахунки необхідні для тіней та освітлення виконувалися спеціалізованими блоками, які не могли запускати довільні програми.

Ця демо є першим прикладом "Шейдерів". Шейдер (Shader) — це програма яка може виконуватись на GPU. Існує кілька типів шейдерів, але першими з'явилися вершинні та піксельні шейдери. Вершинні шейдери виконуються для кожної вершини, і вони обчислюють властивості вершини для якої виконуються. У той час як піксельні шейдери виконуються для кожного пікселя, і, простіше кажучи, відповідають за обчислення остаточного кольору пікселя.

Ця демо показує чого можуть досягти піксельні шейдери, зокрема, як піксельні шейдери дозволяють поверхні змінювати свої властивості на основі певних умов.

## Compute Shaders (Обчислювальні шейдери)

Battlefield: Bad Company 2 (2010) використав Compute Shaders.

<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/-AxiUMiKGLY?si=OFAJoKVLLUJBJWL4" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

Compute Shaders — це новий тип шейдера. На відміну від вершинних або піксельних шейдерів, вони не прив’язані безпосередньо до графіки, вам не потрібна геометрія для їх запуску. Єдине що вам потрібно це самі шейдери та кілька копій для запуску. Це забезпечує велику гнучкість того що можна з ними робити.

Спосіб їх використання в Battlefield: Bad Company 2 досить цікавий. По-перше рендериться вся геометрія, але замість того щоб зразу обчислювати освітлення, ми зберігаємо інформацію про кожен піксель у текстурах щоб обчислити освітлення пізніше. Після рендеру всієї геометрії ми обчислюємо освітлення для усіх пікселів за допомогою Computer Shader'а. Одна з переваг цього полягає в тому, що ви можете попередньо розрахувати список джерел світла, які впливають на кожну частину екрана, оскільки до моменту візуалізації всієї геометрії ви маєте повний буфер глибини та можете обчислити межі кожної частини екрану.

## Апаратне прискорення трасування променів

Battlefield V (2018) використав Апаратне прискорене трасування променів.

<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/F-ZlMl9L3kM?si=LXGd-3kmEj7v-G1r" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

До цього моменту, комп’ютерна графіка в реальному часі використовувала підхід проходу по всій геометрії, щоб з'ясувати який колір отримає кожен піксель. За допомогою трасування променів ви пішли б іншим шляхом, від пікселя до геометрії. Спочатку ви будуєте "Структуру прискорення" (Acceleration Structure), яка містить геометрію яка вас цікавить, потім ви можете її використати для обрахунку перетину геометрії та променів. Наприклад, щоб з'ясувати яку геометрію видно в даному пікселі, ви можете трасувати промінь з камери який відповідає даному пікселю, і найближча геометрія, на яку потрапляє цей промінь, є геометрією, видимою для даного пікселя.

## Чому це все важливо?

Незважаючи на те, що історія графіки в реальному часі налічує багато десятиліть, усі ті самі поняття та ідеї використовуються й сьогодні. Усе, що описано тут, все ще доступне та використовується на практиці в сучасних додатках.
